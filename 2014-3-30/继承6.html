<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="author" content="智能社 - zhinengshe.com" />
<meta name="copyright" content="智能社 - zhinengshe.com" />
<title>智能社 - www.zhinengshe.com</title>
<script>
function Person(name, age)
{
	this.name=name;
	this.age=age;
}

Person.prototype.showName=function ()
{
	alert(this.name);
};
Person.prototype.showAge=function ()
{
	alert(this.age);
};

//--------------------------------------

function Worker(name, age, job)
{
	Person.apply(this, arguments);
	
	this.job=job;
}

//方法1：引用
Worker.prototype=Person.prototype;

Worker.prototype.showJob=function ()
{
	alert(this.job);
};


var oW=new Worker('blue', 18, '打杂的');

var oP=new Person('张三', 21);

alert(oP.showJob);//这就是直接赋值拿过来父级方法出现的问题，因为是引用赋值，所以造成子集的原型跟父级原型指向相同，所以当给子集的原型添加函数时，父级原型也有了这个方法，而这是不应该有的，因为他本应该是子集独有的方法，父级是不应该有的
</script>
</head>

<body>

</body>
</html>
